{"./":{"url":"./","title":"说明","keywords":"","body":"Getting Started with Knative《Knative 入门中文版》 关于本书 Getting Started with Knative 是一本由 Pivotal 公司赞助 O’Reilly 出品的电子书，英文版下载地址：https://content.pivotal.io/ebooks/getting-started-with-knative。 关于 Knative Knative 是一个基于 Kubernetes 的，用于构建、部署和管理现代 serverless 应用的平台。 贡献 参与本书翻译请参阅规范。 版权 ServiceMesher 社区出于学习和技术交流的目的将本书翻译成中文版，如有侵权将立即删除。 Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-03 14:22:48 "},"preface.html":{"url":"preface.html","title":"前言","summary":"本章是全书的前言，用于说明本书的成因、划定目标读者、致谢等。","keywords":"","body":"前言 Kubernetes 赢了。这不是夸大其词，事实就是如此。越来越多的人开始基于容器部署，而 Kubernetes 已经成为容器编排的事实标准。但是，Kubernetes 自己也承认，它是一个容器而不是代码平台。它可以作为一个运行和管理容器的很好的平台，但是这些容器是如何构建、运行、扩展和路由很大程度上是由用户自己决定的。这些是 Knative 想要补充的缺失部分。 也许你已经在生产上使用 Kubernetes，或者你是一个前沿技术爱好者，梦想着将你基于 OS/2 运行的组织现代化。不管怎样，本报告都没有假定太多东西，只是要求您知道容器是什么，具有 Kubernetes 的一些基本知识，可以访问 Kubernetes 集群。如果这些您都不具备的话，那么 Minikube 是一个很好的选择。 我们将使用大量代码示例和预先构建的容器镜像，这些镜像我们都为读者开源，您可以从 http://github.com/gswk 找到所有代码示例，并在 http://hub.docker.com/u/gswk 找到所有容器镜像。您还可以在 http://gswkbook.com 找到这两个存储库以及其他重要参考资料的链接。 我们对 Knative 的未来十分期待。虽然我们来自 Pivotal——Knative 最大的贡献者之—— 但本报告仅出自于对 Knative 的发展前景充满期待的我们。报告中包含了我们的观点，有的读者可能不认同这些观点，还可能会热情地告诉我们为什么我们错了。没关系！这个领域非常新，并且不断重新定义自己。至少，本报告将让您思考无服务器架构（serverless），您会和我们一样对 Knative 感到兴奋。 目标读者 我们本质上是开发人员，所以这份报告主要是针对开发人员编写的。在整个报告中，我们将探索 serverless 架构模式，并向开发人员展示自服务用例示例（例如构建和部署代码）。然而，Knative 吸引了不同角色的技术人员。特别是，将 Knative 组件作为更大平台的一部分或与他们的系统集成的想法会引起运维和平台构建者们的极大兴趣。当这些受众探索如何使用Knative 来实现其特定目的时，本报告将对他们非常有用。 你将学到什么 尽管本报告并不旨在详解 Knative 的全部功能，但已足够深入，可以带您入门 Knative，了解它的工作原理和使用方式。初步了解了 Knative 后，我们将花一些时间研究如何使用它的每个主要组件。然后转到一些高级用例，最后通过构建一个真实的示例应用来结束，该应用将充分利用您在本报告中学到的所有知识。 致谢 我们要感谢 Pivotal。我们都是第一次合作写书，如果没有 Pivotal 团队的支持，可能就不会有本书。技术营销总监 Dan Baskette（我们的老板）和产品营销副总裁 Richard Seroter 在 Pivotal 和领导者的成长中发挥了重要作用。我们要感谢 Jared Ruckle、Derrick Harris 和 Jeff Kelly，他们给予我们很多帮助。我们还要感谢 Tevin Rawls，他是 Pivotal 团队的一名优秀实习生，帮助我们在第 7 章中为我们的演示构建了前端。当然，我们要感谢 O’Reilly 团队所有人的支持和指导。非常感谢整个 Knative 社区，尤其是那些在 Pivotal 帮助我们的人。最后我们要感谢 Virginia Wilson、Nic Williams 博士、Mark Fisher、Nate Schutta、Michael Kehoe 和 Andrew Martin 花时间审阅我们的稿件。 Brian McClain：我要感谢我的妻子 Sarah 在我写作过程中给予我不断的支持和鼓励。我还要感谢我们的两只狗，Tony 和 Brutus，让我几乎把所有时间都用在这份报告上。还要感谢我们的三只猫 Tyson、Marty 和 Doc，它们有时候会趴在我的笔记本电脑上呼呼大睡，这让我可以更积极地投入写作，感谢它们的陪伴。最后，感谢我的合著者 Bryan Friedman，没有他，我是不可能完成这份报告的。Pivotal 告诉我，合作是 1+1 大于 2。 Bryan Friedman：感谢我的妻子 Alison，她十分支持我的写作，还是我们家最有才华的作家。我还要感谢我两个漂亮的女儿，Madelyn 和 Arielle，她们让我每天都变得更好。我也有一个忠诚的办公室伙伴，我的狗 Princeton，它大多只是喜欢待在沙发上，但偶尔会看着我的脸，暗示他为我在这份报告上的工作感到自豪。当然，我无法独自完成这一切，所以我要感谢我的合著者 Brian McClain，他的技术实力和富有感染力的激情在整个过程中给了我极大的帮助。与他合作真是太荣幸了。 Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-07 13:44:25 "},"knative-overview.html":{"url":"knative-overview.html","title":"Knative 概述","summary":"本章是全书的第一章，主要用来介绍 Knative。","keywords":"","body":"Knative 概述 我们有一个信念：以平台的方式提供软件是一个最佳选择。事实证明，标准化的开发和部署流程能让开发人员更专注于新功能的研发，从而减少时间和金钱上的消耗。不仅如此，确保应用程序之间的一致性也意味着其更容易打补丁，更新和监控，从而让运维工作也更加高效。Knative 的目标就是成为这样的现代化平台。 什么是 Knative 我们先来看看 Knative 的目标。Knative 的目标是在基于 Kubernetes 之上为整个开发生命周期提供帮助。它的具体实现方式是：首先使你作为开发人员能够以你想要的语言和以你想要的方式来编写代码，其次帮助你构建和打包应用程序，最后帮助你运行和伸缩应用程序。 为此，Knative 将重点放在三个关键组件上：build（构建）你的应用程序，为其提供流量serving（服务），以及确保应用程序能够轻松地生产和消费event（事件）。 Build（构建） 通过灵活的插件化的构建系统将用户源代码构建成容器。目前已经支持多个构建系统，比如 Google 的 Kaniko，它无需运行 Docker daemon 就可以在 Kubernetes 集群上构建容器镜像。 Serving（服务） 基于负载自动伸缩，包括在没有负载时缩减到零。允许你为多个修订版本（revision）应用创建流量策略，从而能够通过 URL 轻松路由到目标应用程序。 Event（事件） 使得生产和消费事件变得容易。抽象出事件源，并允许操作人员使用自己选择的消息传递层。 Knative 是以 Kubernetes 的一组自定义资源类型（CRD）的方式来安装的，因此只需使用几个 YAML 文件就可以轻松地开始使用 Knative 了。 Kubernetes 知识 由于 Knative 是基于 Kubernetes 的一系列扩展，因此建议你先了解下 Kubernetes 和 Docker 的架构和术语。今后我们会提及以下术语，比如 namespace、Deployment、ReplicaSet 和 Pod。熟悉这些 Kubernetes 术语将帮助你在阅读时更好地理解 Knative 的基本工作。如果你对这些都不熟悉，那么这两个链接：Kubernetes 和 Docker 上都有很棒的培训材料，可以直接在浏览器上阅读。 无服务器架构（serverless）？ 到目前为止，我们已经讨论了应用程序的容器化。但都2019年了，我们读了半章却还没有提到“无服务器架构（serverless）”这个词。也许作为当今技术中被提到最多的一个词，无服务器架构（serverless）仍然在寻找一个整个行业都能认同的定义。许多人都同意这个理念的影响最大的是代码量，比如以前需要编写大型、单一的应用程序，现在你只需编写通过事件来调用的小型、单一用途的函数即可。这些事件可以简单到是一个 HTTP 请求或一个来自消息通道（如 Apache Kafka）的消息。同时事件也可能是间接的，比如这些操作：将图像上传到 Google Cloud Storage或更新了 Amazon 的 DynamoDB 中的一张表。 许多人也都同意这表示着你的代码只在处理请求时才用到计算资源。对于很多托管服务来说，如 Amazon 的 Lambda 或 Google Cloud Functions，这意味着你只需要为活跃期间的计算服务付费，而不是一台7x24小时运行并可能在大部分时间内无所事事的虚拟机。在本地或非托管的无服务器架构（serverless）平台上，则表示代码可以只在需要时运行，在不需要时就停止，从而让你的基础设施能在其他方面自由使用计算资源。 在这些基础原理之上的是一场圣战。有些人坚持无服务器架构（serverless）只适合在托管的云环境中运行，在本地运行这样的平台完全是不对的。其他人则认为它更像是一种哲学理论上的设计。也许这些定义最后会合并，也许不会。就目前来说，随着无服务器架构（serverless）普及率的持续增长，Knative 最有可能成为其标准。 为什么是 Knative ？ 除了关于无服务器架构（serverless）定义的争论之外，下一个逻辑问题是“为什么创造的是 Knative ？”随着基于容器的架构的流行和 Kubernetes 的普及，我们又开始见到一些相同的问题，这些问题之前也出现在平台即服务（PaaS）方案上并推动了其发展。如在构建容器时，我们该如何保证其一致性？谁负责给所有东西打补丁？如何根据需求来伸缩？如何实现零停机部署？ 虽然 Kubernetes 确实已经演进并开始解决其中一些问题，但是之前提到的关于不断发展的无服务器架构（serverless）的概念方面产生了更多的问题。如何管理多个事件类型的一致性？如何定义事件源和目标？ 许多无服务器架构（serverless）或函数即服务（FaaS）框架都尝试回答这些问题，但它们都在用不同的方式来解决问题，且不是所有的解决方案都用到了 Kubernetes。而 Knative 构建在 Kubernetes 的基础上，并为构建和部署无服务器架构（serverless）和基于事件驱动的应用程序提供了一致的标准模式。Knative 减少了这种新的软件开发方法所产生的开销，同时还把路由（routing）和事件（eventing）的复杂性抽象出来。 结论 现在我们已经很好地理解了什么是 Knative 以及它被创造出来的原因，接下来我们将进一步深入了解它。下一章将介绍 Knative 的三个关键组件。我们将详细研究它们，并解释它们是如何协同工作的，以及如何充分发挥它们的潜力。之后，我们将了解如何在 Kubernetes 集群上安装 Knative 和一些更高级的用例。最后，我们将通过演示一个 demo 来展示你能在这个报告中学习到的大部分内容。 Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-10 10:18:36 "},"serving.html":{"url":"serving.html","title":"Serving（服务）","summary":"本章介绍 Knative Serving 组件，描述 Knative Serving 如何部署并为应用和函数 (funtions) 提供服务。","keywords":"","body":"Serving（服务） 即便使用无服务器架构，处理和响应 HTTP 请求的能力依然重要。在开始写代码使用事件触发一个函数之前，您需要有地方来运行代码。 本章探讨 Knative Serving 组件，您将了解 Knative Serving 如何管理部署以及为应用和函数提供服务。通过 Serving，您可以轻松地将一个预先构建好的镜像部署到底层 Kubernetes 集群中。（在第三章： Build，您将看到 Knative Build 可以帮助构建镜像以在 Serving 组件中运行）Knative Serving 维护某一时刻的快照，提供自动化伸缩功能 (既支持扩容，也支持缩容直至为零)，以及处理必要的路由和网络编排。 Serving 模块定义一组特定的对象以控制所有功能：Revision（修订版本）、Configuration （配置）、Route（路由）和 Service（服务）。Knative 使用 Kubernetes CRD（自定义资源）的方式实现这些 Kubernetes 对象。下图 2-1 展示所有 Serving 组件对象模型间的关系。在接下去的章节将具体介绍每个部分。 图 2-1: Knative Serving 对象模型 Configuration（配置）和 Revision（修订版本） Knative Serving 始于 Configuration。您可以在 Configuration 中为部署定义所需的状态。最小化 Configuration 至少包括一个配置名称和一个要部署容器镜像的引用。在 Knative 中，定义的引用为 Revision。Revision 代表一个不变的，某一时刻的代码和 Configuration 的快照。每个 Revision 引用一个特定的容器镜像和运行它所需要的任何特定对象（例如环境变量和卷）。然而，您不必显式创建 Revision。由于 Revision 是不变的，它们从不会被改变和删除，相反，当您修改 Configuration 的时候，Knative 会创建一个 Revision。这允许一个 Configuration 既反映工作负载的当前状态，同时也维护一个它自己的历史 Revision 列表。 以下示例 2-1 展示了一个完整的 Configuration 定义。它指定一个 Revision，该 Revision 使用一个容器镜像仓库 URI 引用一个特定的镜像并且指定其版本标签。 示例 2-1. knative-helloworld/configuration.yml apiVersion: serving.knative.dev/v1alpha1 kind: Configuration metadata: name: knative-helloworld namespace: default spec: revisionTemplate: spec: container: image: docker.io/gswk/knative-helloworld:latest env: - name: MESSAGE value: \"Knative!\" 现在，您可以用一个简单的命令启用该 YAML 文件： $ kubectl apply -f configuration.yaml 自定义端口 默认情况下，Knative 将假定您的应用程序监听 8080 端口。但是，如果不是这样的话，您可以通过 containerPort 参数自定义一个端口： spec: revisionTemplate: spec: container: image: docker.io/gswk/knative-helloworld:latest env: - name: MESSAGE value: \"Knative!\" ports: - containerPort: 8081 就像任意 Kubernetes 对象一样，您可以在系统中使用命令行工具（CLI）查阅 Revision 和 Configuration。您可以使用 kubectl get revisions 和 kubectl get configurations 得到它们的列表。获取我们刚刚创建示例 2-1 的 Configuration，可以使用命令 kubectl get configuration knative-helloworld -oyaml。这将以 YAML 形式显示该 Configuration 完整详情（如下示例 2-2）。 示例 2-2. 命令 kubectl get configuration knative-hellworld -oyaml 的输出 apiVersion: serving.knative.dev/v1alpha1 kind: Configuration metadata: creationTimestamp: YYYY-MM-DDTHH:MM:SSZ generation: 1 labels: serving.knative.dev/route: knative-helloworld serving.knative.dev/service: knative-helloworld name: knative-helloworld namespace: default ownerReferences: - apiVersion: serving.knative.dev/v1alpha1 blockOwnerDeletion: true controller: true kind: Service name: knative-helloworld uid: 9835040f-f29c-11e8-a238-42010a8e0068 resourceVersion: \"374548\" selfLink: \"/apis/serving.knative.dev/v1alpha1/namespaces\\ /default/configurations/knative-helloworld\" uid: 987101a0-f29c-11e8-a238-42010a8e0068 spec: generation: 1 revisionTemplate: metadata: creationTimestamp: null spec: container: image: docker.io/gswk/knative-helloworld:latest name: \"\" resources: {} status: conditions: - lastTransitionTime: YYYY-MM-DDTHH:MM:SSZ status: \"True\" type: Ready latestCreatedRevisionName: knative-helloworld-00001 latestReadyRevisionName: knative-helloworld-00001 observedGeneration: 1 注意示例 2-2 中 status 小节，Configuration 控制器保持对最近创建和就绪 Revison 的追踪。它也包含了 Revision 的适用条件，表明它是否就绪以接收流量。 NOTE Configuration 可以指定一个已有的容器镜像，如示例 2-1 中所示。或者，它也可以选择指向一个 Build 资源以从源代码创建一个容器镜像。第三章：Build 将介绍 Knative Build 组件的详情并提供一些示例。 那么在 Kubernetes 集群内部发生了什么？我们在 Configuration 中指定的容器镜像是什么样子？Knative 转换 Configuration 定义为一些 Kubernetes 对象并在集群中创建它们。在启用 Configuration 后，可以看到相应的 Deployment、ReplicaSet 和 Pod。示例 2-3 展示了所有来自示例 2-1 所创建的对象。 示例 2-3. Knative 创建的 Kubernetes 对象 $ kubectl get deployments -oname deployment.extensions/knative-helloworld-00001-deployment $ kubectl get replicasets -oname replicaset.extensions/knative-helloworld-00001-deployment-5f7b54c768 $ kubectl get pods -oname pod/knative-helloworld-00001-deployment-5f7b54c768-lrqt5 现在我们有了用于运行我们应用的 Pod，但是我们怎么知道该向哪里发送请求？这正是 Route 用武之地。 Route（路由） Knative 中的 Route 提供了一种将流量路由到正在运行的代码的机制。它将一个命名的，HTTP 可寻址端点映射到一个或者多个 Revision。Configuration 本身并不定义 Route。示例 2-4 展示了一个将流量发送到指定 Configuration 最新 Revision 的最基本路由定义。 示例 2-4. knative-helloworld/route.yml apiVersion: serving.knative.dev/v1alpha1 kind: Route metadata: name: knative-helloworld namespace: default spec: traffic: - configurationName: knative-helloworld percent: 100 就像我们对 Configuration 所做的那样，我们可以运行一个简单的命令应用该 YAML 文件： kubectl apply -f route.yaml 这个定义中，Route 发送 100% 流量到由 configurationName 属性指定 Configuration 的最新就绪 Revision，该 Revision 由 Configuration YAML 中 latestReadyRevisionName 属性定义。您可以通过发送如下 curl 命令来测试这些 Route 和 Configuration ： curl -H \"Host: knative-routing-demo.default.example.com\" http://$KNATIVE_INGRESS 通过使用 revisionName 替代 latestReadyRevisionName ，您可以锁定一个 Route 以发送流量到一个指定的 Revision。使用 name 属性，您也可以通过可寻址子域名访问 Revision。示例 2-5 同时展示两种场景。 示例 2-5. knative-routing-demo/route.yml apiVersion: serving.knative.dev/v1alpha1 kind: Route metadata: name: knative-routing-demo namespace: default spec: traffic: - revisionName: knative-routing-demo-00001 name: v1 percent: 100 我们可以再一次使用简单命令应用该 YAML 文件： kubectl apply -f route.yaml 指定的 Revision 可以使用 v1 子域名访问，如下 curl 命令所示： curl -H \"Host: v1.knative-routing-demo.default.example.com\" http://$KNATIVE_INGRESS NOTE Knative 默认使用 example.com 域名，但不适合生产使用。您会注意到在 curl 命令 (v1.knative-routing-demo.default.example.com) 中作为一个主机头传递的 URL 包含该默认值作为域名后缀。URL 格式遵循模式 {REVISION_NAME}.{SERVICE_NAME}.{NAMESPACE}.{DOMAIN} 。 在这个案例中，子域名中 default 部分指的是命名空间。您将在第六章：部署注意事项一节中学习到如何改变这些值以及如何使用自定义域名。 Knative 也允许以百分比的方式跨 Revision 进行流量分配。支持诸如增量发布、蓝绿部署或者其他复杂的路由场景。您将在第六章看到这些以及其他案例。 Autoscaler（自动伸缩器）和 Activator（激活器） Serverless 的一个关键原则是可以按需扩容以满足需要和缩容以节省资源。Serverless 负载应当可以一直缩容至零。这意味着如果没有请求进入，则不会运行容器实例。Knative 使用两个关键组件以实现该功能。它将 Autoscaler 和 Activator 实现为集群中的 Pod。您可以看到它们伴随其他 Serving 组件一起运行在 knative-serving 命名空间中（参见示例 2-6）。 示例 2-6. kubectl get pods -n knative-serving 输出 NAME READY STATUS RESTARTS AGE activator-69dc4755b5-p2m5h 2/2 Running 0 7h autoscaler-7645479876-4h2ds 2/2 Running 0 7h controller-545d44d6b5-2s2vt 1/1 Running 0 7h webhook-68fdc88598-qrt52 1/1 Running 0 7h Autoscaler 收集打到 Revision 并发请求数量的有关信息。为了做到这一点，它在 Revision Pod 内运行一个称之为 queue-proxy 的容器，该 Pod 中也运行用户提供的 (user-provided) 镜像。可以在相应 Revision Pod 上，通过运行 kubectl describe 命令可以看到这些容器 (参见示例 2-7)。 示例 2-7. kubectl describe pod knative-helloworld-00001-deployment-id 输出片段 ... Containers: user-container: Container ID: docker://f02dc... Image: index.docker.io/gswk/knative-helloworld... ... queue-proxy: Container ID: docker://1afcb... Image: gcr.io/knative-releases/github.com/knative... ... queue-proxy 检测该 Revision 上观察到的并发量，然后它每隔一秒将此数据发送到 Autoscaler。Autoscaler 每两秒对这些指标进行评估。基于评估的结果，它增加或者减少 Revision 部署的规模。 默认情况下，Autoscaler 尝试维持每 Pod 每秒平均 100 个并发请求。这些并发目标和平均并发窗口均可以变化。Autoscaler 也能够被配置为利用 Kubernets HPA (Horizontal Pod Autoscaler) 来替代该默认配置。这将基于 CPU 使用率来自动伸缩但不支持缩容至零。这些设定都能够通过 Revision 元数据注解 (annotations) 定制。有关这些注解的详情，请参阅 Knative 文档。 例如，一个 Revision 每秒收到 350 个请求并且每次请求大约需要处理 0.5 秒。使用默认设置 (每 Pod 100 个并发请求)，这个 Revision 将扩展至两个 Pod： 350 * .5 = 175 175 / 100 = 1.75 ceil(1.75) = 2 pods Autoscaler 也负责缩容至零。Revision 处于 Active (激活) 状态才接受请求。当一个 Revision 停止接受请求时，Autoscaler 将其置为 Reserve (待命) 状态，条件是每 Pod 平均并发必须持续 30 秒保持为 0 (这是默认设置，但可以配置)。 处于 Reserve 状态下，一个 Revision 底层部署缩容至零并且所有到它的流量均路由至 Activator。Activator 是一个共享组件，其捕获所有到待命 Revisios 的流量。当它收到一个到某一待命 Revision 的请求后，它转变 Revision 状态至 Active。然后代理请求至合适的 Pods。 Autoscaler 如何伸缩 Autoscaler 采用的伸缩算法针对两个独立的时间间隔计算所有数据点的平均值。它维护两个时间窗，分别是 60 秒和 6 秒。Autoscaler 使用这些数据以两种模式运作：Stable Mode (稳定模式) 和 Panic Mode (忙乱模式)。在 Stable 模式下，它使用 60 秒时间窗平均值决定如何伸缩部署以满足期望的并发量。 如果 6 秒窗口的平均并发量两次到达期望目标，Autoscaler 转换为 Panic Mode 并使用 6 秒时间窗。这让它更加快捷的响应瞬间流量的增长。它也仅仅在 Panic Mode 期间扩容以防止 Pod 数量快速波动。如果超过 60 秒没有扩容发生，Autoscaler 会转换回 Stable Mode。 图 2-2 显示 Autoscaler 和 Activator 如何和 Routes 及 Revisions 协同工作。 图 2-2: Autoscaler 和 Activator 如何和 Routes 及 Revisions 互动。 WARN Autoscaler 和 Activator 均是 Knative 中快速演化的部分。参阅最新 Knative 文档获取最近改进。 服务 在 Knative 中，Service 管理负责的整个生命周期。包括部署、路由和回滚。（不要将 Knative Service 和 Kubernetes Service 混淆。它们是不同的资源。） Knative Service 控制一系列组成软件的 Route 和 Configuration。Knative Service 可以被看作是一段代码 —— 您正在部署的应用或者函数。 一个 Service 注意确保一个应用有一个 Route、一个 Configuation，以及为每次 Service 更新产生的一个新 Revision。当创建一个 Service 时，您没有特别定义一个 Route，Knative 创建一个发送流量到最新 Revision 的路由。您可以选择一个特定的 Revision 以路由流量到该 Revision。 不要求您明确创建一个 Service。Route 和 Configuration 可以被分开在不同的 YAML 文件（如示例 2-1 和 示例 2-4）。在这种情形下，您可以应用每个单独的对象到集群。然而，推荐的方式使用一个 Service 来编排 Route 和 Configuration。示例 2-8 所示文件用于替换来自示例 2-1 和示例 2-4 定义的 configuation.yml 和 route.yml。 示例 2-8. knative-helloworld/service.yml apiVersion: serving.knative.dev/v1alpha1 kind: Service metadata: name: knative-helloworld namespace: default spec: runLatest: configuration: revisionTemplate: spec: container: image: docker.io/gswk/knative-helloworld:latest 注意这个 service.yml 文件和 configuration.yml 非常相似。这个文件定义 Configuration 并且是最小化 Service 定义。由于这里没有 Route 定义，一个默认 Route 指向最新 Revision。Service 控制器整体追踪它所有的 configuration 和 Route 的状态。然后反映这些状态在它的 ConfigurationsReady 和 RoutesReady conditions 属性里。当通过 CLI 使用 kubectl get ksvc 命令请求 Knative Service 信息的时候，这些状态可以被看到。 示例 2-9. kubectl get ksvc knative-helloworld -oyaml 命令输出片段 apiVersion: serving.knative.dev/v1alpha1 kind: Service metadata: ... name: knative-helloworld namespace: default ... spec: ... status: conditions: - lastTransitionTime: YYYY-MM-DDTHH:MM:SSZ status: \"True\" type: ConfigurationsReady - lastTransitionTime: YYYY-MM-DDTHH:MM:SSZ status: \"True\" type: Ready - lastTransitionTime: YYYY-MM-DDTHH:MM:SSZ status: \"True\" type: RoutesReady domain: knative-helloworld.default.example.com domainInternal: knative-helloworld.default.svc.cluster.local latestCreatedRevisionName: knative-helloworld-00001 latestReadyRevisionName: knative-helloworld-00001 observedGeneration: 1 targetable: domainInternal: knative-helloworld.default.svc.cluster.local traffic: - percent: 100 revisionName: knative-helloworld-00001 示例 2-9 显示这个命令的输出。 小结 至此已经向您介绍了 Service、Route、Configuration 和 Revision。Revision 是不变的并且只能经由 Configuration 改变而被创建。您可以分别单独创建 Configuration 和 Route，或者把它们组合在一起并定义为一个 Service。理解 Serving 组件的这些构建块是使用 Knative 的基础。您部署的应用均需要一个 Service 或者 Configuration 以在 Knative 中作为容器运行。 但是，如何打包您的源代码进入一个容器镜像以使用本章介绍的方式进行部署？第三章将回答这些问题并且向您介绍 Knative Build 组件。 Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-12 14:09:27 "},"build.html":{"url":"build.html","title":"Build（构建）","summary":"","keywords":"","body":"Build（构建） Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-03 14:17:48 "},"eventing.html":{"url":"eventing.html","title":"Eventing（事件）","summary":"","keywords":"","body":"Eventing（事件） Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-03 14:17:52 "},"installing-knative.html":{"url":"installing-knative.html","title":"Knative 安装","summary":"","keywords":"","body":"Knative 安装 Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-03 14:30:13 "},"using-knative.html":{"url":"using-knative.html","title":"Knative 使用","summary":"","keywords":"","body":"Knative 使用 Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-03 14:17:59 "},"putting-it-all-together.html":{"url":"putting-it-all-together.html","title":"演练","summary":"","keywords":"","body":"演练 Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-03 14:18:03 "},"what-is-next.html":{"url":"what-is-next.html","title":"下一步","summary":"","keywords":"","body":"下一步 Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-03 14:18:07 "}}