{"./":{"url":"./","title":"说明","keywords":"","body":"Getting Started with Knative《Knative 入门中文版》 关于本书 Getting Started with Knative 是一本由 Pivotal 公司赞助 O’Reilly 出品的电子书，英文版下载地址：https://content.pivotal.io/ebooks/getting-started-with-knative。 关于 Knative Knative 是一个基于 Kubernetes 的，用于构建、部署和管理现代 serverless 应用的平台。 贡献 参与本书翻译请参阅规范。 版权 ServiceMesher 社区出于学习和技术交流的目的将本书翻译成中文版，如有侵权将立即删除。 Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-03 14:22:48 "},"preface.html":{"url":"preface.html","title":"前言","summary":"本章是全书的前言，用于说明本书的成因、划定目标读者、致谢等。","keywords":"","body":"前言 Kubernetes 赢了。这不是夸大其词，事实就是如此。越来越多的人开始基于容器部署，而 Kubernetes 已经成为容器编排的事实标准。但是，Kubernetes 自己也承认，它是一个容器而不是代码平台。它可以作为一个运行和管理容器的很好的平台，但是这些容器是如何构建、运行、扩展和路由很大程度上是由用户自己决定的。这些是 Knative 想要补充的缺失部分。 也许你已经在生产上使用 Kubernetes，或者你是一个前沿技术爱好者，梦想着将你基于 OS/2 运行的组织现代化。不管怎样，本报告都没有假定太多东西，只是要求您知道容器是什么，具有 Kubernetes 的一些基本知识，可以访问 Kubernetes 集群。如果这些您都不具备的话，那么 Minikube 是一个很好的选择。 我们将使用大量代码示例和预先构建的容器镜像，这些镜像我们都为读者开源，您可以从 http://github.com/gswk 找到所有代码示例，并在 http://hub.docker.com/u/gswk 找到所有容器镜像。您还可以在 http://gswkbook.com 找到这两个存储库以及其他重要参考资料的链接。 我们对 Knative 的未来十分期待。虽然我们来自 Pivotal——Knative 最大的贡献者之—— 但本报告仅出自于对 Knative 的发展前景充满期待的我们。报告中包含了我们的观点，有的读者可能不认同这些观点，还可能会热情地告诉我们为什么我们错了。没关系！这个领域非常新，并且不断重新定义自己。至少，本报告将让您思考无服务器架构（serverless），您会和我们一样对 Knative 感到兴奋。 目标读者 我们本质上是开发人员，所以这份报告主要是针对开发人员编写的。在整个报告中，我们将探索 serverless 架构模式，并向开发人员展示自服务用例示例（例如构建和部署代码）。然而，Knative 吸引了不同角色的技术人员。特别是，将 Knative 组件作为更大平台的一部分或与他们的系统集成的想法会引起运维和平台构建者们的极大兴趣。当这些受众探索如何使用Knative 来实现其特定目的时，本报告将对他们非常有用。 你将学到什么 尽管本报告并不旨在详解 Knative 的全部功能，但已足够深入，可以带您入门 Knative，了解它的工作原理和使用方式。初步了解了 Knative 后，我们将花一些时间研究如何使用它的每个主要组件。然后转到一些高级用例，最后通过构建一个真实的示例应用来结束，该应用将充分利用您在本报告中学到的所有知识。 致谢 我们要感谢 Pivotal。我们都是第一次合作写书，如果没有 Pivotal 团队的支持，可能就不会有本书。技术营销总监 Dan Baskette（我们的老板）和产品营销副总裁 Richard Seroter 在 Pivotal 和领导者的成长中发挥了重要作用。我们要感谢 Jared Ruckle、Derrick Harris 和 Jeff Kelly，他们给予我们很多帮助。我们还要感谢 Tevin Rawls，他是 Pivotal 团队的一名优秀实习生，帮助我们在第 7 章中为我们的演示构建了前端。当然，我们要感谢 O’Reilly 团队所有人的支持和指导。非常感谢整个 Knative 社区，尤其是那些在 Pivotal 帮助我们的人。最后我们要感谢 Virginia Wilson、Nic Williams 博士、Mark Fisher、Nate Schutta、Michael Kehoe 和 Andrew Martin 花时间审阅我们的稿件。 Brian McClain：我要感谢我的妻子 Sarah 在我写作过程中给予我不断的支持和鼓励。我还要感谢我们的两只狗，Tony 和 Brutus，让我几乎把所有时间都用在这份报告上。还要感谢我们的三只猫 Tyson、Marty 和 Doc，它们有时候会趴在我的笔记本电脑上呼呼大睡，这让我可以更积极地投入写作，感谢它们的陪伴。最后，感谢我的合著者 Bryan Friedman，没有他，我是不可能完成这份报告的。Pivotal 告诉我，合作是 1+1 大于 2。 Bryan Friedman：感谢我的妻子 Alison，她十分支持我的写作，还是我们家最有才华的作家。我还要感谢我两个漂亮的女儿，Madelyn 和 Arielle，她们让我每天都变得更好。我也有一个忠诚的办公室伙伴，我的狗 Princeton，它大多只是喜欢待在沙发上，但偶尔会看着我的脸，暗示他为我在这份报告上的工作感到自豪。当然，我无法独自完成这一切，所以我要感谢我的合著者 Brian McClain，他的技术实力和富有感染力的激情在整个过程中给了我极大的帮助。与他合作真是太荣幸了。 Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-07 13:44:25 "},"knative-overview.html":{"url":"knative-overview.html","title":"Knative 概述","summary":"本章是全书的第一章，主要用来介绍 Knative。","keywords":"","body":"Knative 概述 我们有一个信念：以平台的方式提供软件是一个最佳选择。事实证明，标准化的开发和部署流程能让开发人员更专注于新功能的研发，从而减少时间和金钱上的消耗。不仅如此，确保应用程序之间的一致性也意味着其更容易打补丁，更新和监控，从而让运维工作也更加高效。Knative 的目标就是成为这样的现代化平台。 什么是 Knative 我们先来看看 Knative 的目标。Knative 的目标是在基于 Kubernetes 之上为整个开发生命周期提供帮助。它的具体实现方式是：首先使你作为开发人员能够以你想要的语言和以你想要的方式来编写代码，其次帮助你构建和打包应用程序，最后帮助你运行和伸缩应用程序。 为此，Knative 将重点放在三个关键组件上：build（构建）你的应用程序，为其提供流量serving（服务），以及确保应用程序能够轻松地生产和消费event（事件）。 Build（构建） 通过灵活的插件化的构建系统将用户源代码构建成容器。目前已经支持多个构建系统，比如 Google 的 Kaniko，它无需运行 Docker daemon 就可以在 Kubernetes 集群上构建容器镜像。 Serving（服务） 基于负载自动伸缩，包括在没有负载时缩减到零。允许你为多个修订版本（revision）应用创建流量策略，从而能够通过 URL 轻松路由到目标应用程序。 Event（事件） 使得生产和消费事件变得容易。抽象出事件源，并允许操作人员使用自己选择的消息传递层。 Knative 是以 Kubernetes 的一组自定义资源类型（CRD）的方式来安装的，因此只需使用几个 YAML 文件就可以轻松地开始使用 Knative 了。 Kubernetes 知识 由于 Knative 是基于 Kubernetes 的一系列扩展，因此建议你先了解下 Kubernetes 和 Docker 的架构和术语。今后我们会提及以下术语，比如 namespace、Deployment、ReplicaSet 和 Pod。熟悉这些 Kubernetes 术语将帮助你在阅读时更好地理解 Knative 的基本工作。如果你对这些都不熟悉，那么这两个链接：Kubernetes 和 Docker 上都有很棒的培训材料，可以直接在浏览器上阅读。 无服务器架构（serverless）？ 到目前为止，我们已经讨论了应用程序的容器化。但都2019年了，我们读了半章却还没有提到“无服务器架构（serverless）”这个词。也许作为当今技术中被提到最多的一个词，无服务器架构（serverless）仍然在寻找一个整个行业都能认同的定义。许多人都同意这个理念的影响最大的是代码量，比如以前需要编写大型、单一的应用程序，现在你只需编写通过事件来调用的小型、单一用途的函数即可。这些事件可以简单到是一个 HTTP 请求或一个来自消息通道（如 Apache Kafka）的消息。同时事件也可能是间接的，比如这些操作：将图像上传到 Google Cloud Storage或更新了 Amazon 的 DynamoDB 中的一张表。 许多人也都同意这表示着你的代码只在处理请求时才用到计算资源。对于很多托管服务来说，如 Amazon 的 Lambda 或 Google Cloud Functions，这意味着你只需要为活跃期间的计算服务付费，而不是一台7x24小时运行并可能在大部分时间内无所事事的虚拟机。在本地或非托管的无服务器架构（serverless）平台上，则表示代码可以只在需要时运行，在不需要时就停止，从而让你的基础设施能在其他方面自由使用计算资源。 在这些基础原理之上的是一场圣战。有些人坚持无服务器架构（serverless）只适合在托管的云环境中运行，在本地运行这样的平台完全是不对的。其他人则认为它更像是一种哲学理论上的设计。也许这些定义最后会合并，也许不会。就目前来说，随着无服务器架构（serverless）普及率的持续增长，Knative 最有可能成为其标准。 为什么是 Knative ？ 除了关于无服务器架构（serverless）定义的争论之外，下一个逻辑问题是“为什么创造的是 Knative ？”随着基于容器的架构的流行和 Kubernetes 的普及，我们又开始见到一些相同的问题，这些问题之前也出现在平台即服务（PaaS）方案上并推动了其发展。如在构建容器时，我们该如何保证其一致性？谁负责给所有东西打补丁？如何根据需求来伸缩？如何实现零停机部署？ 虽然 Kubernetes 确实已经演进并开始解决其中一些问题，但是之前提到的关于不断发展的无服务器架构（serverless）的概念方面产生了更多的问题。如何管理多个事件类型的一致性？如何定义事件源和目标？ 许多无服务器架构（serverless）或函数即服务（FaaS）框架都尝试回答这些问题，但它们都在用不同的方式来解决问题，且不是所有的解决方案都用到了 Kubernetes。而 Knative 构建在 Kubernetes 的基础上，并为构建和部署无服务器架构（serverless）和基于事件驱动的应用程序提供了一致的标准模式。Knative 减少了这种新的软件开发方法所产生的开销，同时还把路由（routing）和事件（eventing）的复杂性抽象出来。 结论 现在我们已经很好地理解了什么是 Knative 以及它被创造出来的原因，接下来我们将进一步深入了解它。下一章将介绍 Knative 的三个关键组件。我们将详细研究它们，并解释它们是如何协同工作的，以及如何充分发挥它们的潜力。之后，我们将了解如何在 Kubernetes 集群上安装 Knative 和一些更高级的用例。最后，我们将通过演示一个 demo 来展示你能在这个报告中学习到的大部分内容。 Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-10 10:18:36 "},"serving.html":{"url":"serving.html","title":"Serving（服务）","summary":"本章介绍 Knative Serving 组件，描述 Knative Serving 如何部署并为应用和函数 (funtions) 提供服务。","keywords":"","body":"Serving（服务） 即便使用无服务器架构，处理和响应 HTTP 请求的能力依然重要。在开始写代码使用事件触发一个函数之前，您需要有地方来运行代码。 本章探讨 Knative Serving 组件，您将了解 Knative Serving 如何管理部署以及为应用和函数提供服务。通过 Serving，您可以轻松地将一个预先构建好的镜像部署到底层 Kubernetes 集群中。（在第三章： Build，您将看到 Knative Build 可以帮助构建镜像以在 Serving 组件中运行）Knative Serving 维护某一时刻的快照，提供自动化伸缩功能 (既支持扩容，也支持缩容直至为零)，以及处理必要的路由和网络编排。 Serving 模块定义一组特定的对象以控制所有功能：Revision（修订版本）、Configuration （配置）、Route（路由）和 Service（服务）。Knative 使用 Kubernetes CRD（自定义资源）的方式实现这些 Kubernetes 对象。下图 2-1 展示所有 Serving 组件对象模型间的关系。在接下去的章节将具体介绍每个部分。 图 2-1: Knative Serving 对象模型 Configuration（配置）和 Revision（修订版本） Knative Serving 始于 Configuration。您可以在 Configuration 中为部署定义所需的状态。最小化 Configuration 至少包括一个配置名称和一个要部署容器镜像的引用。在 Knative 中，定义的引用为 Revision。Revision 代表一个不变的，某一时刻的代码和 Configuration 的快照。每个 Revision 引用一个特定的容器镜像和运行它所需要的任何特定对象（例如环境变量和卷）。然而，您不必显式创建 Revision。由于 Revision 是不变的，它们从不会被改变和删除，相反，当您修改 Configuration 的时候，Knative 会创建一个 Revision。这允许一个 Configuration 既反映工作负载的当前状态，同时也维护一个它自己的历史 Revision 列表。 以下示例 2-1 展示了一个完整的 Configuration 定义。它指定一个 Revision，该 Revision 使用一个容器镜像仓库 URI 引用一个特定的镜像并且指定其版本标签。 示例 2-1. knative-helloworld/configuration.yml apiVersion: serving.knative.dev/v1alpha1 kind: Configuration metadata: name: knative-helloworld namespace: default spec: revisionTemplate: spec: container: image: docker.io/gswk/knative-helloworld:latest env: - name: MESSAGE value: \"Knative!\" 现在，您可以用一个简单的命令启用该 YAML 文件： $ kubectl apply -f configuration.yaml 自定义端口 默认情况下，Knative 将假定您的应用程序监听 8080 端口。但是，如果不是这样的话，您可以通过 containerPort 参数自定义一个端口： spec: revisionTemplate: spec: container: image: docker.io/gswk/knative-helloworld:latest env: - name: MESSAGE value: \"Knative!\" ports: - containerPort: 8081 就像任意 Kubernetes 对象一样，您可以在系统中使用命令行工具（CLI）查阅 Revision 和 Configuration。您可以使用 kubectl get revisions 和 kubectl get configurations 得到它们的列表。获取我们刚刚创建示例 2-1 的 Configuration，可以使用命令 kubectl get configuration knative-helloworld -oyaml。这将以 YAML 形式显示该 Configuration 完整详情（如下示例 2-2）。 示例 2-2. 命令 kubectl get configuration knative-hellworld -oyaml 的输出 apiVersion: serving.knative.dev/v1alpha1 kind: Configuration metadata: creationTimestamp: YYYY-MM-DDTHH:MM:SSZ generation: 1 labels: serving.knative.dev/route: knative-helloworld serving.knative.dev/service: knative-helloworld name: knative-helloworld namespace: default ownerReferences: - apiVersion: serving.knative.dev/v1alpha1 blockOwnerDeletion: true controller: true kind: Service name: knative-helloworld uid: 9835040f-f29c-11e8-a238-42010a8e0068 resourceVersion: \"374548\" selfLink: \"/apis/serving.knative.dev/v1alpha1/namespaces\\ /default/configurations/knative-helloworld\" uid: 987101a0-f29c-11e8-a238-42010a8e0068 spec: generation: 1 revisionTemplate: metadata: creationTimestamp: null spec: container: image: docker.io/gswk/knative-helloworld:latest name: \"\" resources: {} status: conditions: - lastTransitionTime: YYYY-MM-DDTHH:MM:SSZ status: \"True\" type: Ready latestCreatedRevisionName: knative-helloworld-00001 latestReadyRevisionName: knative-helloworld-00001 observedGeneration: 1 注意示例 2-2 中 status 小节，Configuration 控制器保持对最近创建和就绪 Revison 的追踪。它也包含了 Revision 的适用条件，表明它是否就绪以接收流量。 NOTE Configuration 可以指定一个已有的容器镜像，如示例 2-1 中所示。或者，它也可以选择指向一个 Build 资源以从源代码创建一个容器镜像。第三章：Build 将介绍 Knative Build 组件的详情并提供一些示例。 那么在 Kubernetes 集群内部发生了什么？我们在 Configuration 中指定的容器镜像是什么样子？Knative 转换 Configuration 定义为一些 Kubernetes 对象并在集群中创建它们。在启用 Configuration 后，可以看到相应的 Deployment、ReplicaSet 和 Pod。示例 2-3 展示了所有来自示例 2-1 所创建的对象。 示例 2-3. Knative 创建的 Kubernetes 对象 $ kubectl get deployments -oname deployment.extensions/knative-helloworld-00001-deployment $ kubectl get replicasets -oname replicaset.extensions/knative-helloworld-00001-deployment-5f7b54c768 $ kubectl get pods -oname pod/knative-helloworld-00001-deployment-5f7b54c768-lrqt5 现在我们有了用于运行我们应用的 Pod，但是我们怎么知道该向哪里发送请求？这正是 Route 用武之地。 Route（路由） Knative 中的 Route 提供了一种将流量路由到正在运行的代码的机制。它将一个命名的，HTTP 可寻址端点映射到一个或者多个 Revision。Configuration 本身并不定义 Route。示例 2-4 展示了一个将流量发送到指定 Configuration 最新 Revision 的最基本路由定义。 示例 2-4. knative-helloworld/route.yml apiVersion: serving.knative.dev/v1alpha1 kind: Route metadata: name: knative-helloworld namespace: default spec: traffic: - configurationName: knative-helloworld percent: 100 就像我们对 Configuration 所做的那样，我们可以运行一个简单的命令应用该 YAML 文件： kubectl apply -f route.yaml 这个定义中，Route 发送 100% 流量到由 configurationName 属性指定 Configuration 的最新就绪 Revision，该 Revision 由 Configuration YAML 中 latestReadyRevisionName 属性定义。您可以通过发送如下 curl 命令来测试这些 Route 和 Configuration ： curl -H \"Host: knative-routing-demo.default.example.com\" http://$KNATIVE_INGRESS 通过使用 revisionName 替代 latestReadyRevisionName ，您可以锁定一个 Route 以发送流量到一个指定的 Revision。使用 name 属性，您也可以通过可寻址子域名访问 Revision。示例 2-5 同时展示两种场景。 示例 2-5. knative-routing-demo/route.yml apiVersion: serving.knative.dev/v1alpha1 kind: Route metadata: name: knative-routing-demo namespace: default spec: traffic: - revisionName: knative-routing-demo-00001 name: v1 percent: 100 我们可以再一次使用简单命令应用该 YAML 文件： kubectl apply -f route.yaml 指定的 Revision 可以使用 v1 子域名访问，如下 curl 命令所示： curl -H \"Host: v1.knative-routing-demo.default.example.com\" http://$KNATIVE_INGRESS NOTE Knative 默认使用 example.com 域名，但不适合生产使用。您会注意到在 curl 命令 (v1.knative-routing-demo.default.example.com) 中作为一个主机头传递的 URL 包含该默认值作为域名后缀。URL 格式遵循模式 {REVISION_NAME}.{SERVICE_NAME}.{NAMESPACE}.{DOMAIN} 。 在这个案例中，子域名中 default 部分指的是命名空间。您将在第六章：部署注意事项一节中学习到如何改变这些值以及如何使用自定义域名。 Knative 也允许以百分比的方式跨 Revision 进行流量分配。支持诸如增量发布、蓝绿部署或者其他复杂的路由场景。您将在第六章看到这些以及其他案例。 Autoscaler（自动伸缩器）和 Activator（激活器） Serverless 的一个关键原则是可以按需扩容以满足需要和缩容以节省资源。Serverless 负载应当可以一直缩容至零。这意味着如果没有请求进入，则不会运行容器实例。Knative 使用两个关键组件以实现该功能。它将 Autoscaler 和 Activator 实现为集群中的 Pod。您可以看到它们伴随其他 Serving 组件一起运行在 knative-serving 命名空间中（参见示例 2-6）。 示例 2-6. kubectl get pods -n knative-serving 输出 NAME READY STATUS RESTARTS AGE activator-69dc4755b5-p2m5h 2/2 Running 0 7h autoscaler-7645479876-4h2ds 2/2 Running 0 7h controller-545d44d6b5-2s2vt 1/1 Running 0 7h webhook-68fdc88598-qrt52 1/1 Running 0 7h Autoscaler 收集打到 Revision 并发请求数量的有关信息。为了做到这一点，它在 Revision Pod 内运行一个称之为 queue-proxy 的容器，该 Pod 中也运行用户提供的 (user-provided) 镜像。可以在相应 Revision Pod 上，通过运行 kubectl describe 命令可以看到这些容器 (参见示例 2-7)。 示例 2-7. kubectl describe pod knative-helloworld-00001-deployment-id 输出片段 ... Containers: user-container: Container ID: docker://f02dc... Image: index.docker.io/gswk/knative-helloworld... ... queue-proxy: Container ID: docker://1afcb... Image: gcr.io/knative-releases/github.com/knative... ... queue-proxy 检测该 Revision 上观察到的并发量，然后它每隔一秒将此数据发送到 Autoscaler。Autoscaler 每两秒对这些指标进行评估。基于评估的结果，它增加或者减少 Revision 部署的规模。 默认情况下，Autoscaler 尝试维持每 Pod 每秒平均 100 个并发请求。这些并发目标和平均并发窗口均可以变化。Autoscaler 也能够被配置为利用 Kubernets HPA (Horizontal Pod Autoscaler) 来替代该默认配置。这将基于 CPU 使用率来自动伸缩但不支持缩容至零。这些设定都能够通过 Revision 元数据注解 (annotations) 定制。有关这些注解的详情，请参阅 Knative 文档。 例如，一个 Revision 每秒收到 350 个请求并且每次请求大约需要处理 0.5 秒。使用默认设置 (每 Pod 100 个并发请求)，这个 Revision 将扩展至两个 Pod： 350 * .5 = 175 175 / 100 = 1.75 ceil(1.75) = 2 pods Autoscaler 也负责缩容至零。Revision 处于 Active (激活) 状态才接受请求。当一个 Revision 停止接受请求时，Autoscaler 将其置为 Reserve (待命) 状态，条件是每 Pod 平均并发必须持续 30 秒保持为 0 (这是默认设置，但可以配置)。 处于 Reserve 状态下，一个 Revision 底层部署缩容至零并且所有到它的流量均路由至 Activator。Activator 是一个共享组件，其捕获所有到待命 Revisios 的流量。当它收到一个到某一待命 Revision 的请求后，它转变 Revision 状态至 Active。然后代理请求至合适的 Pods。 Autoscaler 如何伸缩 Autoscaler 采用的伸缩算法针对两个独立的时间间隔计算所有数据点的平均值。它维护两个时间窗，分别是 60 秒和 6 秒。Autoscaler 使用这些数据以两种模式运作：Stable Mode (稳定模式) 和 Panic Mode (忙乱模式)。在 Stable 模式下，它使用 60 秒时间窗平均值决定如何伸缩部署以满足期望的并发量。 如果 6 秒窗口的平均并发量两次到达期望目标，Autoscaler 转换为 Panic Mode 并使用 6 秒时间窗。这让它更加快捷的响应瞬间流量的增长。它也仅仅在 Panic Mode 期间扩容以防止 Pod 数量快速波动。如果超过 60 秒没有扩容发生，Autoscaler 会转换回 Stable Mode。 图 2-2 显示 Autoscaler 和 Activator 如何和 Routes 及 Revisions 协同工作。 图 2-2: Autoscaler 和 Activator 如何和 Routes 及 Revisions 互动。 WARN Autoscaler 和 Activator 均是 Knative 中快速演化的部分。参阅最新 Knative 文档获取最近改进。 服务 在 Knative 中，Service 管理负责的整个生命周期。包括部署、路由和回滚。（不要将 Knative Service 和 Kubernetes Service 混淆。它们是不同的资源。） Knative Service 控制一系列组成软件的 Route 和 Configuration。Knative Service 可以被看作是一段代码 —— 您正在部署的应用或者函数。 一个 Service 注意确保一个应用有一个 Route、一个 Configuation，以及为每次 Service 更新产生的一个新 Revision。当创建一个 Service 时，您没有特别定义一个 Route，Knative 创建一个发送流量到最新 Revision 的路由。您可以选择一个特定的 Revision 以路由流量到该 Revision。 不要求您明确创建一个 Service。Route 和 Configuration 可以被分开在不同的 YAML 文件（如示例 2-1 和 示例 2-4）。在这种情形下，您可以应用每个单独的对象到集群。然而，推荐的方式使用一个 Service 来编排 Route 和 Configuration。示例 2-8 所示文件用于替换来自示例 2-1 和示例 2-4 定义的 configuation.yml 和 route.yml。 示例 2-8. knative-helloworld/service.yml apiVersion: serving.knative.dev/v1alpha1 kind: Service metadata: name: knative-helloworld namespace: default spec: runLatest: configuration: revisionTemplate: spec: container: image: docker.io/gswk/knative-helloworld:latest 注意这个 service.yml 文件和 configuration.yml 非常相似。这个文件定义 Configuration 并且是最小化 Service 定义。由于这里没有 Route 定义，一个默认 Route 指向最新 Revision。Service 控制器整体追踪它所有的 configuration 和 Route 的状态。然后反映这些状态在它的 ConfigurationsReady 和 RoutesReady conditions 属性里。当通过 CLI 使用 kubectl get ksvc 命令请求 Knative Service 信息的时候，这些状态可以被看到。 示例 2-9. kubectl get ksvc knative-helloworld -oyaml 命令输出片段 apiVersion: serving.knative.dev/v1alpha1 kind: Service metadata: ... name: knative-helloworld namespace: default ... spec: ... status: conditions: - lastTransitionTime: YYYY-MM-DDTHH:MM:SSZ status: \"True\" type: ConfigurationsReady - lastTransitionTime: YYYY-MM-DDTHH:MM:SSZ status: \"True\" type: Ready - lastTransitionTime: YYYY-MM-DDTHH:MM:SSZ status: \"True\" type: RoutesReady domain: knative-helloworld.default.example.com domainInternal: knative-helloworld.default.svc.cluster.local latestCreatedRevisionName: knative-helloworld-00001 latestReadyRevisionName: knative-helloworld-00001 observedGeneration: 1 targetable: domainInternal: knative-helloworld.default.svc.cluster.local traffic: - percent: 100 revisionName: knative-helloworld-00001 示例 2-9 显示这个命令的输出。 小结 至此已经向您介绍了 Service、Route、Configuration 和 Revision。Revision 是不变的并且只能经由 Configuration 改变而被创建。您可以分别单独创建 Configuration 和 Route，或者把它们组合在一起并定义为一个 Service。理解 Serving 组件的这些构建块是使用 Knative 的基础。您部署的应用均需要一个 Service 或者 Configuration 以在 Knative 中作为容器运行。 但是，如何打包您的源代码进入一个容器镜像以使用本章介绍的方式进行部署？第三章将回答这些问题并且向您介绍 Knative Build 组件。 Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-12 14:09:27 "},"build.html":{"url":"build.html","title":"Build（构建）","summary":"本章是全书的第三章，主要介绍 Build （构建）的几个相关的组件，通过示例展示了如何进行配合来减少手动构建，更轻松的完成代码的打包和构建。","keywords":"","body":"Build（构建） Knative 的 Serving（服务）组件是解决如何从容器到 URL 的，而 Build 组件是解决如何从源代码到容器的。Build resource 允许您定义如何编译代码和构建容器，而不是指向预构建的容器镜像。这确保了在将代码发送到容器镜像库之前以一致的方式编译和打包代码。在本章中将会向你介绍一些新的组件： Build 驱动构建过程的自定义 Kubernetes 资源。在定义构建时，您将定义如何获取源代码以及如何创建将运行源代码的容器镜像。 Build Template 封装可重复构建步骤集合并允许对构建进行参数化的模板。 Service Account 允许对私有资源（如 Git 存储库或容器镜像库）进行身份验证。 [备注] 在编写本文时，有一些活动的工作要迁移 Build Pipeline（构建流水线），对构建中的流水线进行重构更类似于 CI/CD 流水线的 Knative。这意味着除了编译和打包代码外，Knative 中的构建还可以轻松地运行测试并发布这些结果。请密切关注 Knative 的未来版本，了解这一变化。 Service Account（服务账户） 在开始配置构建之前，你首先会面临一个紧迫的问题：如何在构建时获得需要验证的服务？如何从私有的 Git 仓库拉取代码和如何把容器镜像推到 Docker Hub 里面？为此，你可以利用两个 Kubernetes 原生组件的组合：Secret 和 Service Account 。Secret 可以让你安全地存储这些经过身份验证的请求所需的凭据，Service Account 可以让你灵活地为多个构建提供和维护凭据，而无需每次构建新应用程序时手动配置它们。 在 Example 3-1 中，首先创建一个 Secret ，命名为 dockerhub-account，里面包含需要使用的凭据。当然，可以像应用其他 YAML 一样应用它，如 Example 3-2 所示。 Example 3-1. knative-build-demo/secret.yaml apiVersion: v1 kind: Secret metadata: name: dockerhub-account annotations: build.knative.dev/docker-0: https://index.docker.io/v1/ type: kubernetes.io/basic-auth data: # 'echo -n \"username\" | base64' username: dXNlcm5hbWUK # 'echo -n \"password\" | base64' password: cGFzc3dvcmQK Example 3-2. kubectl apply kubectl apply -f knative-build-demo/secret.yaml 首先要注意的是，username 和 password 在传递给 Kubernetes 时都是 base64 编码的。还注意到，使用 basic-auth 根据 Docker Hub 进行身份验证，这意味着将使用用户名和密码进行身份验证，而不是类似于 access token（访问令牌）的东西。此外，Knative 还附带了开箱即用的 ssh-auth，这允许使用 SSH 私钥从私有 Git 存储库中拉取代码。 除了将 Secret 命名为 dockerhub-account 之外，还对 Secret 进行了注解。Annotation（注解）是说明连接到特定主机时使用哪些凭据的一种方式。在 Example 3-3 中，定义了连接到 Docker Hub 时使用的基于身份的验证凭证集。 我的凭据安全吗？ 使用 base64 编码对凭证进行编码不是为了安全性，而是为了可靠地将这些字符串传输到其中 Kubernetes 。在后端，Kubernetes 提供了关于如何加密机密的更多选项。有关加密的详细资料 Secret，请参考 Kubernetes 文档 。 一旦创建了名为 dockerhub-account 的 Secret，接下来必须创建要运行应用程序的 Service Account ，以便它能够访问 Kubernetes 中的凭据。配置很简单，如 Example 3-3 所示。 Example 3-3. knative-build-demo/serviceaccount.yaml apiVersion: v1 kind: ServiceAccount metadata: name: build-bot secrets: - name: dockerhub-account 示例中创建了一个名为 build-bot 的 ServiceAccount ，允许它访问 dockerhub-account Secret 。在示例中当推送容器镜像时，Knative 使用这些凭证对 Docker Hub 进行身份验证。 The Build Resource（构建资源） 首先从 Hello World 应用程序开始。这是一个简单的 Go 应用程序，它监听端口8080并以 “Hello from Knative!” 作为 HTTP GET 请求的回应。代码如 Example 3-4 所示。 Example 3-4. knative-helloworld/app.go package main import ( \"fmt\" \"log\" \"net/http\" ) func handlePost(rw http.ResponseWriter, req *http.Request) { fmt.Fprintf(rw, \"%s\", \"Hello from Knative!\") } func main() { log.Print(\"Starting server on port 8080...\") http.HandleFunc(\"/\", handlePost) log.Fatal(http.ListenAndServe(\":8080\", nil)) } 然后编写一个 Dockerfile 来构建代码和容器，如 Example 3-5 所示。 Example 3-5. knative-helloworld/Dockerfle FROM golang ADD . /knative-build-demo WORKDIR /knative-build-demo RUN go build ENTRYPOINT ./knative-build-demo EXPOSE 8080 在前面的第2章中，你已经在本地构建了容器并手动将其推送到容器镜像库。然而，Knative 为在 Kubernetes 集群中使用 Build 来完成这些步骤提供了一种更好的方式。与 Configuration （配置）和 Route（路由）一样，Build 也可以简单地作为 Kubernetes 自定义资源（CRD）来通过 YAML 定义的方式实现。在深入研究每个组件之前，先来看一看 Example 3-6 ，看看 Build 的配置是什么样的。 Example 3-6. knative-build-demo/service.yaml apiVersion: serving.knative.dev/v1alpha1 kind: Service metadata: name: knative-build-demo namespace: default spec: runLatest: configuration: build: serviceAccountName: build-bot source: git: url: https://github.com/gswk/knative-helloworld.git revision: master template: name: kaniko arguments: - name: IMAGE value: docker.io/gswk/knative-build-demo:latest revisionTemplate: spec: container: image: docker.io/gswk/knative-build-demo:latest 在构建步骤之前，你还会看到定义源代码位置的源代码部分。目前，Knative 发布了三个代码源选项： git：Git 仓库，可以选择使用参数来定义分支、标记或提交 SHA 。 gcs：位于谷歌云存储中的存档文件。 自定义：任意容器镜像仓库。这允许用户编写自己的源代码，只要将源代码放在 /work space 目录中即可。 只需要安装一个额外的组件，即 Build Template（构建模板）。将会在 “Build template” 一节中向你更深入地介绍这些内容，但是现在，先将继续使用在 YAML 中定义的方式，在本例中是 Kaniko Build Template 如 Example 3-7 所示。 Example 3-7. Install the Kaniko Build Template kubectl apply -f https:// raw.githubusercontent.com/knative/build-templates/master/kaniko/kaniko.yaml 通过应用模板，可以像在 Serving 示例中那样部署服务，配置如 Example 3-8 所示。 Example 3-8. Deploy our application kubectl apply -f knative-build-demo/service.yaml 然后，该构建将运行以下步骤： 从 gswk/knative-helloworld 的 GitHub repo 中拉取代码。 在 repo 中使用 Kaniko Build Template (下一节将详细描述)。 使用前面设置的 “build-bot” Service Account 将容器推送到 gswk/knative-build-demo 上的 Docker Hub。 使用新构建的容器部署应用程序。 Build Template（构建模板） 在 Example 3-6 中，使用了一个 Build Template ，但从未真正解释过 Build Template 是什么或它做什么。简单来说，Build Template 是可共享的、封装的、参数化的构建步骤集合。目前，Knative 已经支持多个 Build Template ，包括： Kaniko 在运行的容器中构建容器镜像，而不依赖于运行 Docker daemon 。 Jib 为Java应用程序构建容器镜像。 Buildpack 自动检测应用程序的运行时，并建立一个容器镜像使用 Cloud Foundry Buildpack。 虽然这并不是可用模板的完整列表，但是可以轻松地集成 Knative 社区开发的新模板。安装 Build Template 和应用 YAML 文件安装 Service（服务）、Route（路由）或 Build configuration（构建配置）一样简单： kubectl apply -f https://raw.githubusercontent.com/knative/ build-templates/master/kaniko/kaniko.yaml 然后可以像其他configura配置一样应用 Example 3-6 来部署应用程序，同时向它发送请求，就像在第2章中所做的那样： kubectl apply -f knative-build-demo/service.yml $ curl -H \"Host: knative-build-demo.default.example.com\" http://$KNATIVE_INGRESS 在 Example 3-9 中继续使用 Kaniko 作为参考来进一步观察 Build Template 。 Example 3-9. https://github.com/knative/build-templates/blob/master/kaniko/kaniko.yaml apiVersion: build.knative.dev/v1alpha1 kind: BuildTemplate metadata: name: kaniko spec: parameters: - name: IMAGE description: The name of the image to push - name: DOCKERFILE description: Path to the Dockerfile to build. default: /workspace/Dockerfile steps: - name: build-and-push image: gcr.io/kaniko-project/executor args: - --dockerfile=${DOCKERFILE} - --destination=${IMAGE} Build Template 的 steps 部分具有与 Build 完全相同的语法，只是使用命名变量进行模板化。实际上，除了用变量替换路径之外，steps 部分看起来非常类似于 Example 3-6 的模板部分。parameters 部分在 Build Template 所期望的参数周围放置了一些结构。Kaniko Build Template 需要一个定义在何处推送容器镜像的 IMAGE 参数，但是有一个可选的 DOCKERFILE 参数，如果没有定义该参数，则提供一个默认值。 结论 Knative 中的 Build 在部署应用程序时删除了许多手动步骤。此外，Build Template 提供了一些构建代码和删除手动管理组件数量的好方法。随着时间的推移，可能会有越来越多的 Build Template 被构建并与 Knative 社区共享，这可能是最值得关注的事情之一。 我们已经花了很多时间来构建和运行应用程序，但是 serverless 的最大承诺之一是，它可以使您的服务轻松地连接到事件源。在下一章中，将研究 Knative 的 Eventing（事件）组件以及开箱即用的所有可用事件源。 Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-14 16:07:59 "},"eventing.html":{"url":"eventing.html","title":"Eventing（事件）","summary":"","keywords":"","body":"Eventing（事件） Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-03 14:17:52 "},"installing-knative.html":{"url":"installing-knative.html","title":"Knative 安装","summary":"","keywords":"","body":"Knative 安装 Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-03 14:30:13 "},"using-knative.html":{"url":"using-knative.html","title":"Knative 使用","summary":"","keywords":"","body":"Knative 使用 Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-03 14:17:59 "},"putting-it-all-together.html":{"url":"putting-it-all-together.html","title":"演练","summary":"","keywords":"","body":"演练 Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-03 14:18:03 "},"what-is-next.html":{"url":"what-is-next.html","title":"下一步","summary":"","keywords":"","body":"下一步 Copyright © ServiceMesher 2019 all right reserved，powered by Gitbook 最后更新于 2019-03-03 14:18:07 "}}